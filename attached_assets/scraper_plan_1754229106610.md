# Final Integration Plan: Medicaid Audit Search-to-Queue Pipeline

Based on your answers, here's the complete, clean implementation plan:

## Architecture Overview
- **Queue**: Simple PostgreSQL table (no Redis/Celery needed)
- **Processing**: Background with Flask + threading (simple, no extra dependencies)
- **UI**: Single page with AJAX updates
- **Deduplication**: URL-based (sufficient for your use case)

## Database Schema

```sql
-- Scraping queue table (simplified)
CREATE TABLE scraping_queue (
    id SERIAL PRIMARY KEY,
    url TEXT NOT NULL UNIQUE,  -- URL is unique identifier
    title TEXT NOT NULL,
    source_domain TEXT,
    metadata JSONB,
    ai_classification JSONB,
    status VARCHAR(50) DEFAULT 'pending',  -- pending, downloading, processing, completed, failed, duplicate
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    error_message TEXT,
    report_id INTEGER REFERENCES reports(id),  -- Links after successful processing
    user_override BOOLEAN DEFAULT FALSE  -- For manual override of AI classification
);

CREATE INDEX idx_queue_status ON scraping_queue(status);
CREATE INDEX idx_queue_created ON scraping_queue(created_at);

-- Search history
CREATE TABLE search_history (
    id SERIAL PRIMARY KEY,
    search_params JSONB,
    results_count INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- For tracking duplicate checks
CREATE TABLE duplicate_checks (
    id SERIAL PRIMARY KEY,
    queue_item_id INTEGER REFERENCES scraping_queue(id),
    existing_report_id INTEGER REFERENCES reports(id),
    similarity_score FLOAT,  -- For future enhancement
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## Core Implementation

### 1. **Search Integration Service**
```python
# services/audit_search_service.py
import threading
from datetime import datetime
from scraper.search import MedicaidAuditSearcher
from scraper.classifier import MedicaidAuditClassifier

class AuditSearchService:
    def __init__(self, db):
        self.db = db
        self.searcher = MedicaidAuditSearcher()
        self.classifier = MedicaidAuditClassifier()
        
    def search_and_classify(self, days_back=30):
        """Execute search with AI classification."""
        # Search
        results = self.searcher.search(days_back=days_back, max_results=50)
        
        # Classify
        classified_results = self.classifier.classify_batch(results)
        
        # Check for duplicates
        for result in classified_results:
            result['is_duplicate'] = self._check_duplicate(result['url'])
            result['duplicate_report'] = self._get_duplicate_info(result['url'])
        
        # Save search history
        self._save_search_history(len(classified_results), days_back)
        
        return classified_results
    
    def _check_duplicate(self, url):
        """Check if URL exists in reports or queue."""
        # Check main reports table
        existing_report = self.db.session.query(Report).filter_by(
            original_report_source_url=url
        ).first()
        
        if existing_report:
            return True
            
        # Check queue
        in_queue = self.db.session.query(ScrapingQueue).filter_by(
            url=url
        ).filter(
            ScrapingQueue.status.in_(['pending', 'downloading', 'processing'])
        ).first()
        
        return in_queue is not None
    
    def add_to_queue(self, items, user_overrides=None):
        """Add items to processing queue."""
        user_overrides = user_overrides or {}
        added_count = 0
        
        for item in items:
            # Skip if already in queue or processed
            if self._check_duplicate(item['url']):
                continue
                
            # Apply user override if provided
            if item['url'] in user_overrides:
                item['ai_classification']['is_medicaid_audit'] = user_overrides[item['url']]
                item['user_override'] = True
            
            queue_item = ScrapingQueue(
                url=item['url'],
                title=item['title'],
                source_domain=item['source'],
                metadata=item.get('metadata', {}),
                ai_classification=item.get('ai_classification', {}),
                user_override=item.get('user_override', False)
            )
            
            self.db.session.add(queue_item)
            added_count += 1
        
        self.db.session.commit()
        
        # Start processing in background
        if added_count > 0:
            self._start_background_processing()
            
        return added_count
    
    def _start_background_processing(self):
        """Start processing queue in background thread."""
        thread = threading.Thread(target=self._process_queue)
        thread.daemon = True
        thread.start()
```

### 2. **Queue Processor**
```python
# services/queue_processor.py
import requests
import hashlib
from datetime import datetime

class QueueProcessor:
    def __init__(self, app, db):
        self.app = app
        self.db = db
        
    def process_queue(self):
        """Process all pending items in queue."""
        with self.app.app_context():
            while True:
                item = self._get_next_item()
                if not item:
                    break
                    
                self._process_item(item)
    
    def _get_next_item(self):
        """Get next pending item from queue."""
        return self.db.session.query(ScrapingQueue).filter_by(
            status='pending'
        ).filter(
            ScrapingQueue.retry_count < 3  # Max 3 attempts
        ).order_by(
            ScrapingQueue.created_at
        ).first()
    
    def _process_item(self, item):
        """Process a single queue item."""
        try:
            # Update status
            item.status = 'downloading'
            self.db.session.commit()
            
            # Download PDF
            response = requests.get(item.url, timeout=30)
            response.raise_for_status()
            
            # Calculate hash
            file_hash = hashlib.sha256(response.content).hexdigest()
            
            # Check if duplicate by hash
            existing = self.db.session.query(Report).filter_by(
                file_hash=file_hash
            ).first()
            
            if existing:
                item.status = 'duplicate'
                item.report_id = existing.id
                # Record duplicate
                dup_check = DuplicateCheck(
                    queue_item_id=item.id,
                    existing_report_id=existing.id
                )
                self.db.session.add(dup_check)
            else:
                # Process through existing pipeline
                # This is where you'd call your existing processing
                report = self._create_report(item, response.content)
                item.status = 'completed'
                item.report_id = report.id
                
        except Exception as e:
            item.status = 'failed'
            item.error_message = str(e)
            item.retry_count += 1
            
            # Reset to pending if retries remaining
            if item.retry_count < 3:
                item.status = 'pending'
        
        finally:
            item.completed_at = datetime.now()
            self.db.session.commit()
```

### 3. **Flask Routes**
```python
# routes/audit_search.py
from flask import Blueprint, render_template, jsonify, request

audit_search_bp = Blueprint('audit_search', __name__)

@audit_search_bp.route('/audit-search')
def search_page():
    """Main search interface."""
    return render_template('audit_search.html')

@audit_search_bp.route('/api/audit-search', methods=['POST'])
def execute_search():
    """Execute search and return results."""
    days_back = request.json.get('days_back', 30)
    
    service = AuditSearchService(db)
    results = service.search_and_classify(days_back)
    
    return jsonify({
        'success': True,
        'results': results,
        'stats': {
            'total': len(results),
            'audits': sum(1 for r in results 
                         if r.get('ai_classification', {}).get('is_medicaid_audit')),
            'duplicates': sum(1 for r in results if r.get('is_duplicate'))
        }
    })

@audit_search_bp.route('/api/queue/add', methods=['POST'])
def add_to_queue():
    """Add selected items to queue."""
    items = request.json.get('items', [])
    user_overrides = request.json.get('overrides', {})
    
    service = AuditSearchService(db)
    added = service.add_to_queue(items, user_overrides)
    
    return jsonify({
        'success': True,
        'added': added
    })

@audit_search_bp.route('/api/queue/status')
def queue_status():
    """Get current queue status."""
    stats = db.session.query(
        ScrapingQueue.status,
        func.count(ScrapingQueue.id)
    ).group_by(ScrapingQueue.status).all()
    
    recent = db.session.query(ScrapingQueue).order_by(
        ScrapingQueue.created_at.desc()
    ).limit(10).all()
    
    return jsonify({
        'stats': dict(stats),
        'recent': [item.to_dict() for item in recent]
    })

@audit_search_bp.route('/api/duplicates/<url>')
def check_duplicates(url):
    """Get duplicate information for a URL."""
    report = db.session.query(Report).filter_by(
        original_report_source_url=url
    ).first()
    
    if report:
        return jsonify({
            'found': True,
            'report': {
                'id': report.id,
                'title': report.report_title,
                'year': report.publication_year,
                'month': report.publication_month
            }
        })
    
    return jsonify({'found': False})
```

### 4. **Frontend Template**
```html
<!-- templates/audit_search.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Medicaid Audit Search</title>
    <style>
        .duplicate-row { background-color: #fff3cd; }
        .selected-row { background-color: #d1ecf1; }
        .ai-override { font-style: italic; color: #dc3545; }
        .status-badge { 
            padding: 3px 8px; 
            border-radius: 3px; 
            font-size: 0.875em; 
        }
        .status-pending { background: #ffc107; }
        .status-processing { background: #17a2b8; color: white; }
        .status-completed { background: #28a745; color: white; }
        .status-failed { background: #dc3545; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Medicaid Audit Search & Queue</h1>
        
        <!-- Search Controls -->
        <div class="search-controls">
            <label>Time Period:</label>
            <select id="timeframe">
                <option value="7">Last 7 Days</option>
                <option value="30" selected>Last 30 Days</option>
                <option value="90">Last Quarter</option>
                <option value="365">Last Year</option>
            </select>
            <button onclick="executeSearch()" class="btn-primary">Search</button>
        </div>
        
        <!-- Results Section -->
        <div id="results-section" style="display:none;">
            <h2>Search Results</h2>
            <div class="results-actions">
                <button onclick="selectAll()">Select All</button>
                <button onclick="selectNone()">Select None</button>
                <button onclick="addToQueue()" class="btn-success">Add Selected to Queue</button>
                <span id="selection-count">0 selected</span>
            </div>
            
            <table id="results-table">
                <thead>
                    <tr>
                        <th>Select</th>
                        <th>Title</th>
                        <th>Source</th>
                        <th>AI: Is Audit?</th>
                        <th>Override</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="results-tbody"></tbody>
            </table>
        </div>
        
        <!-- Duplicates Section -->
        <div id="duplicates-section" style="display:none;">
            <h3>Potential Duplicates</h3>
            <table id="duplicates-table">
                <thead>
                    <tr>
                        <th>Title</th>
                        <th>URL</th>
                        <th>Existing Report</th>
                    </tr>
                </thead>
                <tbody id="duplicates-tbody"></tbody>
            </table>
        </div>
        
        <!-- Queue Status -->
        <div id="queue-status">
            <h3>Queue Status</h3>
            <div id="queue-stats"></div>
        </div>
    </div>
    
    <script>
    let searchResults = [];
    let userOverrides = {};
    
    function executeSearch() {
        const days = document.getElementById('timeframe').value;
        
        fetch('/api/audit-search', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({days_back: parseInt(days)})
        })
        .then(r => r.json())
        .then(data => {
            searchResults = data.results;
            displayResults(data.results);
            displayDuplicates(data.results.filter(r => r.is_duplicate));
            updateQueueStatus();
        });
    }
    
    function displayResults(results) {
        const tbody = document.getElementById('results-tbody');
        tbody.innerHTML = '';
        
        results.forEach((result, idx) => {
            const aiClass = result.ai_classification || {};
            const isAudit = aiClass.is_medicaid_audit;
            
            const row = tbody.insertRow();
            if (result.is_duplicate) row.classList.add('duplicate-row');
            
            row.innerHTML = `
                <td><input type="checkbox" onchange="updateSelection()" 
                    data-idx="${idx}" ${result.is_duplicate ? 'disabled' : ''}></td>
                <td>${result.title}</td>
                <td>${result.source}</td>
                <td>${isAudit ? '✓ Yes' : '✗ No'} (${(aiClass.confidence * 100).toFixed(0)}%)</td>
                <td>
                    <select onchange="setOverride('${result.url}', this.value)" 
                        ${result.is_duplicate ? 'disabled' : ''}>
                        <option value="">AI Decision</option>
                        <option value="true">Force Yes</option>
                        <option value="false">Force No</option>
                    </select>
                </td>
                <td>${result.is_duplicate ? 
                    '<span class="status-badge status-completed">Duplicate</span>' : 
                    '<span class="status-badge status-pending">New</span>'}</td>
            `;
        });
        
        document.getElementById('results-section').style.display = 'block';
    }
    
    function setOverride(url, value) {
        if (value === "") {
            delete userOverrides[url];
        } else {
            userOverrides[url] = value === "true";
        }
    }
    
    function addToQueue() {
        const selected = [];
        document.querySelectorAll('#results-tbody input:checked').forEach(cb => {
            const idx = parseInt(cb.dataset.idx);
            selected.push(searchResults[idx]);
        });
        
        if (selected.length === 0) {
            alert('No items selected');
            return;
        }
        
        fetch('/api/queue/add', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                items: selected,
                overrides: userOverrides
            })
        })
        .then(r => r.json())
        .then(data => {
            alert(`Added ${data.added} items to queue`);
            updateQueueStatus();
            executeSearch(); // Refresh to show updated statuses
        });
    }
    
    function updateQueueStatus() {
        fetch('/api/queue/status')
            .then(r => r.json())
            .then(data => {
                const stats = data.stats;
                document.getElementById('queue-stats').innerHTML = `
                    <span class="status-badge status-pending">Pending: ${stats.pending || 0}</span>
                    <span class="status-badge status-processing">Processing: ${stats.processing || 0}</span>
                    <span class="status-badge status-completed">Completed: ${stats.completed || 0}</span>
                    <span class="status-badge status-failed">Failed: ${stats.failed || 0}</span>
                `;
            });
    }
    
    // Poll queue status every 5 seconds
    setInterval(updateQueueStatus, 5000);
    </script>
</body>
</html>
```
